import os
import streamlit as st
import logging
import json
from datetime import datetime
from typing import Dict, List, Any, Tuple
import plotly.graph_objects as go
from collections import Counter
import openai
from elevenlabs import generate, set_api_key
import re

# No in√≠cio do arquivo, ap√≥s as importa√ß√µes
def initialize_openai_client():
    try:
        # Configurar cliente OpenAI usando a chave correta
        openai.api_key = st.secrets["openai"]["api_key"]
        # Verificar se a chave come√ßa com "sk-" para garantir formato correto
        if not openai.api_key.startswith("sk-"):
            raise ValueError("Formato de API key inv√°lido")
            
        return openai.Client(api_key=openai.api_key)
    except Exception as e:
        logger.error(f"Erro ao inicializar cliente OpenAI: {e}")
        st.error("Erro ao inicializar conex√£o com OpenAI. Verifique a chave da API.")
        return None
# Configura√ß√£o inicial do Streamlit
st.set_page_config(
    page_title="Sistema de An√°lise de Reda√ß√£o ENEM",
    page_icon="üìù",
    layout="wide"
)

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Inicializa√ß√£o dos clientes
try:
    # OpenAI (GPT-4)
    openai.api_key = st.secrets["openai"]["api_key"]
    
    # ElevenLabs
    set_api_key(st.secrets["elevenlabs"]["api_key"])
except Exception as e:
    logger.error(f"Erro na inicializa√ß√£o dos clientes: {e}")
    st.error("Erro ao inicializar conex√µes. Por favor, tente novamente mais tarde.")

# Constantes Globais
COMPETENCIES = {
    "competency1": "Dom√≠nio da Norma Culta",
    "competency2": "Compreens√£o do Tema",
    "competency3": "Sele√ß√£o e Organiza√ß√£o das Informa√ß√µes",
    "competency4": "Conhecimento dos Mecanismos Lingu√≠sticos",
    "competency5": "Proposta de Interven√ß√£o"
}

COMPETENCY_COLORS = {
    "competency1": "#FF6B6B",
    "competency2": "#4ECDC4",
    "competency3": "#45B7D1",
    "competency4": "#FFA07A",
    "competency5": "#98D8C8"
}

# Modelos fine-tuned para cada compet√™ncia
MODELOS_COMPETENCIAS = {
    "competency1": "ft:gpt-4o-2024-08-06:personal:competencia-1:AHDQQucG",
    "competency2": "ft:gpt-4o-2024-08-06:personal:competencia-2:AHDT84HO",
    "competency3": "ft:gpt-4o-2024-08-06:personal:competencia-3:AHDUfZRb",
    "competency4": "ft:gpt-4o-2024-08-06:personal:competencia-4:AHDXewU3",
    "competency5": "ft:gpt-4o-2024-08-06:personal:competencia-5:AHGVPnJG"
}


def pagina_envio_redacao():
    """P√°gina de envio de reda√ß√£o com processamento real"""
    st.title("Envio de Reda√ß√£o ENEM")

    nome_aluno = st.text_input("Nome do aluno:")
    tema_redacao = st.text_input("Tema da reda√ß√£o:")

    if 'texto_redacao' not in st.session_state:
        st.session_state.texto_redacao = ""

    texto_redacao = st.text_area(
        "Digite sua reda√ß√£o aqui:", 
        value=st.session_state.texto_redacao,
        height=400
    )

    # Upload de arquivo txt
    uploaded_file = st.file_uploader("Ou fa√ßa upload de um arquivo .txt", type=['txt'])
    if uploaded_file:
        texto_redacao = uploaded_file.getvalue().decode("utf-8")
        st.session_state.texto_redacao = texto_redacao

    if tema_redacao and texto_redacao:
        if st.button("Processar Reda√ß√£o"):
            with st.spinner("Analisando reda√ß√£o..."):
                try:
                    # Validar entrada
                    valido, msg = validar_redacao(texto_redacao, tema_redacao)
                    if not valido:
                        st.error(msg)
                        return

                    # Processar reda√ß√£o usando as APIs
                    resultados = processar_redacao_completa(texto_redacao, tema_redacao)
                    
                    # Salvar resultados no session_state
                    st.session_state.update({
                        'resultados': resultados,
                        'nome_aluno': nome_aluno,
                        'tema_redacao': tema_redacao,
                        'redacao_texto': texto_redacao
                    })

                    st.success("Reda√ß√£o processada com sucesso!")
                    
                    # Exibir resumo das notas
                    st.write("Notas por compet√™ncia:")
                    for comp, nota in resultados['notas'].items():
                        st.write(f"{COMPETENCIES[comp]}: {nota}")

                except Exception as e:
                    st.error("Erro ao processar a reda√ß√£o.")
                    logger.error(f"Erro ao processar reda√ß√£o: {str(e)}", exc_info=True)
    else:
        st.button("Processar Reda√ß√£o", disabled=True)
        st.warning("Por favor, insira o tema e o texto da reda√ß√£o antes de processar.")


def processar_redacao_completa(redacao_texto: str, tema_redacao: str) -> Dict[str, Any]:
    """
    Processa a reda√ß√£o completa usando as APIs para an√°lise real.
    """
    logger.info("Iniciando processamento da reda√ß√£o")

    resultados = {
        'analises_detalhadas': {},
        'notas': {},
        'erros_especificos': {},
        'justificativas': {},
        'texto_original': redacao_texto
    }
    
    # Processar cada compet√™ncia
    for comp, modelo in MODELOS_COMPETENCIAS.items():
        try:
            # Realizar an√°lise da compet√™ncia usando o modelo espec√≠fico
            if comp == "competency1":
                resultado_analise = analisar_competency1(redacao_texto, tema_redacao)
            elif comp == "competency2":
                resultado_analise = analisar_competency2(redacao_texto, tema_redacao)
            elif comp == "competency3":
                resultado_analise = analisar_competency3(redacao_texto, tema_redacao)
            elif comp == "competency4":
                resultado_analise = analisar_competency4(redacao_texto, tema_redacao)
            else:  # competency5
                resultado_analise = analisar_competency5(redacao_texto, tema_redacao)
            
            # Processar erros identificados
            erros_revisados = resultado_analise.get('erros', [])
            
            # Atribuir nota baseado na an√°lise completa
            if comp == "competency1":
                resultado_nota = atribuir_nota_competency1(resultado_analise['analise'], erros_revisados)
            elif comp == "competency2":
                resultado_nota = atribuir_nota_competency2(resultado_analise['analise'], erros_revisados)
            elif comp == "competency3":
                resultado_nota = atribuir_nota_competency3(resultado_analise['analise'], erros_revisados)
            elif comp == "competency4":
                resultado_nota = atribuir_nota_competency4(resultado_analise['analise'], erros_revisados)
            else:  # competency5
                resultado_nota = atribuir_nota_competency5(resultado_analise['analise'], erros_revisados)
            
            # Preencher resultados
            resultados['analises_detalhadas'][comp] = resultado_analise['analise']
            resultados['notas'][comp] = resultado_nota['nota']
            resultados['justificativas'][comp] = resultado_nota['justificativa']
            resultados['erros_especificos'][comp] = erros_revisados

        except Exception as e:
            logger.error(f"Erro ao processar compet√™ncia {comp}: {str(e)}")
            resultados['analises_detalhadas'][comp] = "Erro na an√°lise"
            resultados['notas'][comp] = 0
            resultados['justificativas'][comp] = "N√£o foi poss√≠vel realizar a an√°lise"
            resultados['erros_especificos'][comp] = []

    return resultados

def pagina_resultado_analise():
    st.title("Resultado da An√°lise")
    
    if 'resultados' not in st.session_state:
        st.warning("Nenhuma an√°lise dispon√≠vel")
        return
        
    # Exibir gr√°fico radar
    criar_grafico_radar(st.session_state.resultados['notas'])
    
    # Exibir an√°lises detalhadas
    for comp, analise in st.session_state.resultados['analises_detalhadas'].items():
        with st.expander(f"{COMPETENCIES[comp]} - Nota: {st.session_state.resultados['notas'][comp]}"):
            st.write(analise)
            
            if comp in st.session_state.resultados['erros_especificos']:
                st.write("**Erros identificados:**")
                for erro in st.session_state.resultados['erros_especificos'][comp]:
                    st.write(formatar_erro(erro))
    
    # Bot√£o para iniciar tutoria
    if st.button("Iniciar Tutoria Personalizada"):
        st.session_state.page = 'tutoria'
        st.rerun()

def validar_redacao(texto: str, tema: str) -> Tuple[bool, str]:
    """
    Valida o texto da reda√ß√£o e o tema.
    
    Args:
        texto: Texto da reda√ß√£o
        tema: Tema da reda√ß√£o
        
    Returns:
        Tupla (√©_v√°lido, mensagem_erro)
    """
    if not texto or not texto.strip():
        return False, "O texto da reda√ß√£o n√£o pode estar vazio."
        
    if not tema or not tema.strip():
        return False, "O tema da reda√ß√£o n√£o pode estar vazio."
        
    palavras = len(texto.split())
    if palavras < 50:
        return False, f"Texto muito curto ({palavras} palavras). M√≠nimo recomendado: 400 palavras."
        
    if palavras > 3000:
        return False, f"Texto muito longo ({palavras} palavras). M√°ximo recomendado: 3000 palavras."
        
    return True, ""

def extrair_erros_do_resultado(resultado: str) -> List[Dict[str, str]]:
    """
    Extrai erros do texto de resultado da an√°lise.
    
    Args:
        resultado: String contendo o resultado da an√°lise
        
    Returns:
        Lista de dicion√°rios contendo os erros identificados
    """
    erros = []
    padrao_erro = re.compile(r'ERRO\n(.*?)\nFIM_ERRO', re.DOTALL)
    matches = padrao_erro.findall(resultado)
    
    for match in matches:
        erro = {}
        for linha in match.split('\n'):
            if ':' in linha:
                chave, valor = linha.split(':', 1)
                chave = chave.strip().lower()
                valor = valor.strip()
                if chave == 'trecho':
                    valor = valor.strip('"')
                erro[chave] = valor
        if 'descri√ß√£o' in erro and 'trecho' in erro:
            erros.append(erro)
    
    return erros

# Continua√ß√£o da fun√ß√£o analisar_competency1
    erros_por_criterio = {}
    for criterio, prompt in criterios.items():
        prompt_formatado = prompt.format(redacao_texto=redacao_texto)
        resposta = client.messages.create(
            model=MODELO_COMP1,
            messages=[{"role": "user", "content": prompt_formatado}],
            temperature=0.3
        )
        erros_por_criterio[criterio] = extrair_erros_do_resultado(resposta.content)
    
    # Reunir todos os erros
    todos_erros = []
    for erros in erros_por_criterio.values():
        todos_erros.extend(erros)
   
    # Separar erros reais de sugest√µes estil√≠sticas
    erros_reais = []
    sugestoes_estilo = []
    
    palavras_chave_sugestao = [
        "pode ser melhorada",
        "poderia ser",
        "considerar",
        "sugerimos",
        "recomendamos",
        "ficaria melhor",
        "seria prefer√≠vel",
        "opcionalmente",
        "para aprimorar",
        "para enriquecer",
        "estilo",
        "clareza",
        "mais elegante",
        "sugest√£o de melhoria",
        "alternativa",
        "opcional"
    ]
    
    for erro in todos_erros:
        eh_sugestao = False
        explicacao = erro.get('explica√ß√£o', '').lower()
        sugestao = erro.get('sugest√£o', '').lower()
        
        # Verificar se √© uma sugest√£o
        if any(palavra in explicacao or palavra in sugestao for palavra in palavras_chave_sugestao):
            sugestoes_estilo.append(erro)
        else:
            # Valida√ß√£o adicional para erros de crase
            if "crase" in erro.get('descri√ß√£o', '').lower():
                explicacao = erro.get('explica√ß√£o', '').lower()
                if (any(termo in explicacao for termo in ['artigo definido', 'sentido definido', 'locu√ß√£o']) and 
                    any(termo in explicacao for termo in ['reg√™ncia', 'preposi√ß√£o', 'artigo feminino'])):
                    erros_reais.append(erro)
            else:
                erros_reais.append(erro)

    # Revis√£o final dos erros reais
    erros_revisados = revisar_erros_competency1(erros_reais, redacao_texto)
    
    # Gerar an√°lise final
    prompt_analise = f"""
    Com base nos seguintes ERROS CONFIRMADOS no texto (excluindo sugest√µes de melhoria estil√≠stica),
    gere uma an√°lise detalhada da Compet√™ncia 1 (Dom√≠nio da Norma Culta):
    
    Total de erros confirmados: {len(erros_revisados)}
    
    Detalhamento dos erros confirmados:
    {json.dumps(erros_revisados, indent=2)}
    
    Observa√ß√£o: Analisar apenas os erros reais que prejudicam a nota, ignorando sugest√µes de melhoria.
    
    Forne√ßa uma an√°lise que:
    1. Avalie o dom√≠nio geral da norma culta considerando apenas erros confirmados
    2. Destaque os tipos de erros mais frequentes e sua gravidade
    3. Analise o impacto dos erros na compreens√£o do texto
    4. Avalie a consist√™ncia no uso da norma culta
    5. Forne√ßa uma vis√£o geral da qualidade t√©cnica do texto
    
    Formato da resposta:
    An√°lise Geral: [Sua an√°lise aqui]
    Erros Principais: [Lista dos erros mais relevantes]
    Impacto na Compreens√£o: [An√°lise do impacto dos erros]
    Consist√™ncia: [Avalia√ß√£o da consist√™ncia no uso da norma]
    Conclus√£o: [Vis√£o geral da qualidade t√©cnica]
    """
    
    resposta_analise = client.messages.create(
        model=MODELO_COMP1,
        messages=[{"role": "user", "content": prompt_analise}],
        temperature=0.3
    )
    
    return {
        'analise': resposta_analise.content,
        'erros': erros_revisados,
        'sugestoes_estilo': sugestoes_estilo,
        'total_erros': len(erros_revisados)
    }

def analisar_competency1(redacao_texto: str, tema_redacao: str) -> Dict[str, Any]:
    """An√°lise da Compet√™ncia 1 usando o modelo fine-tuned"""
    try:
        if 'openai_client' not in st.session_state:
            raise ValueError("Cliente OpenAI n√£o inicializado")
            
        client = st.session_state.openai_client
        
        prompt = f"""
        Analise o dom√≠nio da norma culta na seguinte reda√ß√£o:
        
        Tema: {tema_redacao}
        
        Texto:
        {redacao_texto}
        
        Forne√ßa uma an√°lise detalhada considerando:
        1. Uso correto da norma culta
        2. Desvios gramaticais
        3. Adequa√ß√£o da linguagem
        4. Clareza e precis√£o
        
        Para cada erro identificado, use o formato:
        ERRO
        Trecho: "[trecho exato do texto]"
        Explica√ß√£o: [explica√ß√£o detalhada]
        Sugest√£o: [sugest√£o de corre√ß√£o]
        FIM_ERRO
        """
        
        response = client.chat.completions.create(
            model="ft:gpt-4-0125-preview:personal::8TYkJb4B",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )
        
        analise = response.choices[0].message.content
        erros = extrair_erros_do_resultado(analise)
        
        return {
            'analise': analise,
            'erros': erros
        }
    except Exception as e:
        logger.error(f"Erro na an√°lise da Compet√™ncia 1: {str(e)}")
        raise

def analisar_competency2(redacao_texto: str, tema_redacao: str) -> Dict[str, Any]:
    """An√°lise da Compet√™ncia 2 usando o modelo fine-tuned"""
    try:
        if 'openai_client' not in st.session_state:
            raise ValueError("Cliente OpenAI n√£o inicializado")
            
        client = st.session_state.openai_client
        
        prompt = f"""
        Analise a compreens√£o do tema na seguinte reda√ß√£o:
        
        Tema: {tema_redacao}
        
        Texto:
        {redacao_texto}
        
        Forne√ßa uma an√°lise detalhada considerando:
        1. Compreens√£o da proposta de reda√ß√£o e do tema
        2. Presen√ßa das palavras-chave do tema em cada par√°grafo
        3. Desenvolvimento do tema de forma adequada
        4. Uso e pertin√™ncia do repert√≥rio sociocultural
        5. Clareza no ponto de vista defendido
        6. V√≠nculo entre o repert√≥rio e a discuss√£o proposta
        
        Para cada problema identificado, use o formato:
        ERRO
        Trecho: "[trecho exato do texto]"
        Explica√ß√£o: [explica√ß√£o detalhada]
        Sugest√£o: [sugest√£o de melhoria]
        FIM_ERRO
        """
        
        response = client.chat.completions.create(
            model="ft:gpt-4-0125-preview:personal::8TYmNb5C",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )
        
        analise = response.choices[0].message.content
        erros = extrair_erros_do_resultado(analise)
        
        return {
            'analise': analise,
            'erros': erros
        }
    except Exception as e:
        logger.error(f"Erro na an√°lise da Compet√™ncia 2: {str(e)}")
        raise

def analisar_competency3(redacao_texto: str, tema_redacao: str) -> Dict[str, Any]:
    """An√°lise da Compet√™ncia 3 usando o modelo fine-tuned"""
    try:
        if 'openai_client' not in st.session_state:
            raise ValueError("Cliente OpenAI n√£o inicializado")
            
        client = st.session_state.openai_client
        
        prompt = f"""
        Analise a sele√ß√£o e organiza√ß√£o das informa√ß√µes na seguinte reda√ß√£o:
        
        Tema: {tema_redacao}
        
        Texto:
        {redacao_texto}
        
        Forne√ßa uma an√°lise detalhada considerando:
        1. Progress√£o textual (desenvolvimento das ideias)
        2. Organiza√ß√£o dos par√°grafos e per√≠odos
        3. Encadeamento de ideias entre par√°grafos
        4. Uso de argumentos e contra-argumentos
        5. Coer√™ncia na apresenta√ß√£o das informa√ß√µes
        6. Autoria no desenvolvimento do texto
        
        Para cada problema identificado, use o formato:
        ERRO
        Trecho: "[trecho exato do texto]"
        Explica√ß√£o: [explica√ß√£o detalhada]
        Sugest√£o: [sugest√£o de melhoria]
        FIM_ERRO
        """
        
        response = client.chat.completions.create(
            model="ft:gpt-4-0125-preview:personal::8TYpKc6D",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )
        
        analise = response.choices[0].message.content
        erros = extrair_erros_do_resultado(analise)
        
        return {
            'analise': analise,
            'erros': erros
        }
    except Exception as e:
        logger.error(f"Erro na an√°lise da Compet√™ncia 3: {str(e)}")
        raise

def analisar_competency4(redacao_texto: str, tema_redacao: str) -> Dict[str, Any]:
    """An√°lise da Compet√™ncia 4 usando o modelo fine-tuned"""
    try:
        if 'openai_client' not in st.session_state:
            raise ValueError("Cliente OpenAI n√£o inicializado")
            
        client = st.session_state.openai_client
        
        prompt = f"""
        Analise os mecanismos lingu√≠sticos na seguinte reda√ß√£o:
        
        Tema: {tema_redacao}
        
        Texto:
        {redacao_texto}
        
        Forne√ßa uma an√°lise detalhada considerando:
        1. Uso de conectivos entre par√°grafos e per√≠odos
        2. Articula√ß√£o entre as partes do texto
        3. Recursos de coes√£o textual
        4. Uso de referencia√ß√£o (pronomes, sin√¥nimos, etc.)
        5. Estrutura√ß√£o dos per√≠odos
        6. Transi√ß√µes entre ideias
        
        Para cada problema identificado, use o formato:
        ERRO
        Trecho: "[trecho exato do texto]"
        Explica√ß√£o: [explica√ß√£o detalhada]
        Sugest√£o: [sugest√£o de melhoria]
        FIM_ERRO
        """
        
        response = client.chat.completions.create(
            model="ft:gpt-4-0125-preview:personal::8TYrLd7E",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )
        
        analise = response.choices[0].message.content
        erros = extrair_erros_do_resultado(analise)
        
        return {
            'analise': analise,
            'erros': erros
        }
    except Exception as e:
        logger.error(f"Erro na an√°lise da Compet√™ncia 4: {str(e)}")
        raise

def analisar_competency5(redacao_texto: str, tema_redacao: str) -> Dict[str, Any]:
    """An√°lise da Compet√™ncia 5 usando o modelo fine-tuned"""
    try:
        if 'openai_client' not in st.session_state:
            raise ValueError("Cliente OpenAI n√£o inicializado")
            
        client = st.session_state.openai_client
        
        prompt = f"""
        Analise a proposta de interven√ß√£o na seguinte reda√ß√£o:
        
        Tema: {tema_redacao}
        
        Texto:
        {redacao_texto}
        
        Forne√ßa uma an√°lise detalhada considerando:
        1. Presen√ßa dos elementos obrigat√≥rios:
           - Agente(s) que executar√°(√£o) a a√ß√£o
           - A√ß√£o(√µes) para resolver o problema
           - Modo/meio de execu√ß√£o da a√ß√£o
           - Detalhamento da execu√ß√£o e/ou dos efeitos esperados
           - Finalidade/objetivo da proposta
        2. Detalhamento e articula√ß√£o da proposta
        3. Viabilidade da proposta
        4. Respeito aos direitos humanos
        5. Rela√ß√£o com o problema discutido
        6. N√≠vel de detalhamento das a√ß√µes sugeridas
        
        Para cada problema identificado, use o formato:
        ERRO
        Trecho: "[trecho exato do texto]"
        Explica√ß√£o: [explica√ß√£o detalhada]
        Sugest√£o: [sugest√£o de melhoria]
        FIM_ERRO
        """
        
        response = client.chat.completions.create(
            model="ft:gpt-4-0125-preview:personal::8TYtMe8F",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )
        
        analise = response.choices[0].message.content
        erros = extrair_erros_do_resultado(analise)
        
        return {
            'analise': analise,
            'erros': erros
        }
    except Exception as e:
        logger.error(f"Erro na an√°lise da Compet√™ncia 5: {str(e)}")
        raise

def revisar_erros_competency1(erros_identificados: List[Dict], redacao_texto: str) -> List[Dict]:
    """
    Revisa os erros identificados na Compet√™ncia 1 usando an√°lise contextual aprofundada.
    
    Args:
        erros_identificados: Lista de erros identificados inicialmente
        redacao_texto: Texto completo da reda√ß√£o para an√°lise contextual
        
    Returns:
        Lista de erros validados e revisados
    """
    MODELO_REVISAO_COMP1 = "ft:gpt-4o-2024-08-06:personal:competencia-1:AHDQQucG"
    erros_revisados = []
    
    for erro in erros_identificados:
        # Extrair contexto expandido do erro
        trecho = erro.get('trecho', '')
        inicio_trecho = redacao_texto.find(trecho)
        if inicio_trecho != -1:
            # Pegar at√© 100 caracteres antes e depois para contexto
            inicio_contexto = max(0, inicio_trecho - 100)
            fim_contexto = min(len(redacao_texto), inicio_trecho + len(trecho) + 100)
            contexto_expandido = redacao_texto[inicio_contexto:fim_contexto]
        else:
            contexto_expandido = trecho
            
        prompt_revisao = f"""
        Revise rigorosamente o seguinte erro identificado na Compet√™ncia 1 (Dom√≠nio da Norma Culta).
        
        Erro original:
        {json.dumps(erro, indent=2)}

        Contexto expandido do erro:
        "{contexto_expandido}"

        Texto completo para refer√™ncia:
        {redacao_texto}

        Analise cuidadosamente:
        1. CONTEXTO SINT√ÅTICO:
           - Estrutura completa da frase
           - Fun√ß√£o sint√°tica das palavras
           - Rela√ß√µes de depend√™ncia
           
        2. REGRAS GRAMATICAIS:
           - Regras espec√≠ficas aplic√°veis
           - Exce√ß√µes relevantes
           - Casos especiais
           
        3. IMPACTO NO SENTIDO:
           - Se o suposto erro realmente compromete a compreens√£o
           - Se h√° ambiguidade ou preju√≠zo ao sentido
           - Se √© um desvio real ou varia√ß√£o aceit√°vel
           
        4. ADEQUA√á√ÉO AO ENEM:
           - Crit√©rios espec√≠ficos da prova
           - Impacto na avalia√ß√£o
           - Relev√¢ncia do erro

        Para casos de crase, VERIFIQUE ESPECIFICAMENTE:
        - Se h√° realmente jun√ß√£o de preposi√ß√£o 'a' com artigo definido feminino
        - Se a palavra est√° sendo usada em sentido definido
        - Se h√° reg√™ncia verbal/nominal exigindo preposi√ß√£o
        - O contexto completo da constru√ß√£o

        Formato da resposta:
        REVISAO
        Erro Confirmado: [Sim/N√£o]
        An√°lise Sint√°tica: [An√°lise detalhada da estrutura sint√°tica]
        Regra Aplic√°vel: [Cita√ß√£o da regra gramatical espec√≠fica]
        Explica√ß√£o Revisada: [Explica√ß√£o t√©cnica detalhada]
        Sugest√£o Revisada: [Corre√ß√£o com justificativa]
        Considera√ß√µes ENEM: [Relev√¢ncia para a avalia√ß√£o]
        FIM_REVISAO
        """
        
        try:
            resposta_revisao = client.messages.create(
                model=MODELO_REVISAO_COMP1,
                messages=[{"role": "user", "content": prompt_revisao}],
                temperature=0.2
            )
            
            revisao = extrair_revisao_do_resultado(resposta_revisao.content)
            
            # Valida√ß√£o rigorosa da revis√£o
            if (revisao['Erro Confirmado'] == 'Sim' and
                'An√°lise Sint√°tica' in revisao and
                'Regra Aplic√°vel' in revisao and
                len(revisao.get('Explica√ß√£o Revisada', '')) > 50):
                
                erro_revisado = erro.copy()
                erro_revisado.update({
                    'an√°lise_sint√°tica': revisao['An√°lise Sint√°tica'],
                    'regra_aplic√°vel': revisao['Regra Aplic√°vel'],
                    'explica√ß√£o': revisao['Explica√ß√£o Revisada'],
                    'sugest√£o': revisao['Sugest√£o Revisada'],
                    'considera√ß√µes_enem': revisao['Considera√ß√µes ENEM'],
                    'contexto_expandido': contexto_expandido
                })
                
                # Valida√ß√£o adicional para erros de crase
                if "crase" in erro.get('descri√ß√£o', '').lower():
                    explicacao = revisao['Explica√ß√£o Revisada'].lower()
                    analise = revisao['An√°lise Sint√°tica'].lower()
                    
                    if ('artigo definido' in explicacao and
                        'preposi√ß√£o' in explicacao and
                        any(termo in analise for termo in ['fun√ß√£o sint√°tica', 'reg√™ncia', 'complemento'])):
                        erros_revisados.append(erro_revisado)
                else:
                    erros_revisados.append(erro_revisado)
                    
        except Exception as e:
            logger.error(f"Erro ao revisar: {str(e)}")
            continue
    
    return erros_revisados

def revisar_erros_competency2(erros_identificados: List[Dict], redacao_texto: str) -> List[Dict]:
    """
    Revisa os erros identificados na Compet√™ncia 2.
    
    Args:
        erros_identificados: Lista de erros identificados
        redacao_texto: Texto completo da reda√ß√£o
        
    Returns:
        Lista de erros validados
    """
    MODELO_REVISAO_COMP2 = "ft:gpt-4o-2024-08-06:personal:competencia-2:AHDT84HO"
    erros_revisados = []
    
    for erro in erros_identificados:
        prompt_revisao = f"""
        Revise o seguinte erro identificado na Compet√™ncia 2 (Compreens√£o do Tema) 
        de acordo com os crit√©rios espec√≠ficos do ENEM:

        Erro original:
        {json.dumps(erro, indent=2)}

        Texto da reda√ß√£o:
        {redacao_texto}

        Determine:
        1. Se o erro est√° corretamente identificado
        2. Se a explica√ß√£o e sugest√£o est√£o adequadas aos padr√µes do ENEM
        3. Se h√° considera√ß√µes adicionais relevantes

        Formato da resposta:
        REVISAO
        Erro Confirmado: [Sim/N√£o]
        Explica√ß√£o Revisada: [Nova explica√ß√£o, se necess√°rio]
        Sugest√£o Revisada: [Nova sugest√£o, se necess√°rio]
        Considera√ß√µes ENEM: [Observa√ß√µes espec√≠ficas sobre o erro no contexto do ENEM]
        FIM_REVISAO
        """
        
        try:
            resposta_revisao = client.messages.create(
                model=MODELO_REVISAO_COMP2,
                messages=[{"role": "user", "content": prompt_revisao}],
                temperature=0.2
            )
            
            revisao = extrair_revisao_do_resultado(resposta_revisao.content)
            
            if revisao.get('Erro Confirmado') == 'Sim':
                erro_revisado = erro.copy()
                if 'Explica√ß√£o Revisada' in revisao:
                    erro_revisado['explica√ß√£o'] = revisao['Explica√ß√£o Revisada']
                if 'Sugest√£o Revisada' in revisao:
                    erro_revisado['sugest√£o'] = revisao['Sugest√£o Revisada']
                erro_revisado['considera√ß√µes_enem'] = revisao['Considera√ß√µes ENEM']
                erros_revisados.append(erro_revisado)
                
        except Exception as e:
            logger.error(f"Erro ao revisar: {str(e)}")
            continue
    
    return erros_revisados

def revisar_erros_competency3(erros_identificados: List[Dict], redacao_texto: str) -> List[Dict]:
    """
    Revisa os erros identificados na Compet√™ncia 3.
    
    Args:
        erros_identificados: Lista de erros identificados
        redacao_texto: Texto completo da reda√ß√£o
        
    Returns:
        Lista de erros validados
    """
    MODELO_REVISAO_COMP3 = "ft:gpt-4o-2024-08-06:personal:competencia-3:AHDUfZRb"
    erros_revisados = []
    
    for erro in erros_identificados:
        prompt_revisao = f"""
        Revise o seguinte erro identificado na Compet√™ncia 3 (Sele√ß√£o e Organiza√ß√£o das Informa√ß√µes) 
        de acordo com os crit√©rios espec√≠ficos do ENEM:

        Erro original:
        {json.dumps(erro, indent=2)}

        Texto da reda√ß√£o:
        {redacao_texto}

        Determine:
        1. Se o erro est√° corretamente identificado
        2. Se a explica√ß√£o e sugest√£o est√£o adequadas aos padr√µes do ENEM
        3. Se o erro impacta significativamente a organiza√ß√£o e sele√ß√£o de informa√ß√µes
        4. Se h√° considera√ß√µes adicionais relevantes para a avalia√ß√£o

        Formato da resposta:
        REVISAO
        Erro Confirmado: [Sim/N√£o]
        Explica√ß√£o Revisada: [Nova explica√ß√£o, se necess√°rio]
        Sugest√£o Revisada: [Nova sugest√£o, se necess√°rio]
        Considera√ß√µes ENEM: [Observa√ß√µes espec√≠ficas sobre o erro no contexto do ENEM]
        FIM_REVISAO
        """
        
        try:
            resposta_revisao = client.messages.create(
                model=MODELO_REVISAO_COMP3,
                messages=[{"role": "user", "content": prompt_revisao}],
                temperature=0.2
            )
            
            revisao = extrair_revisao_do_resultado(resposta_revisao.content)
            
            if revisao.get('Erro Confirmado') == 'Sim':
                erro_revisado = erro.copy()
                if 'Explica√ß√£o Revisada' in revisao:
                    erro_revisado['explica√ß√£o'] = revisao['Explica√ß√£o Revisada']
                if 'Sugest√£o Revisada' in revisao:
                    erro_revisado['sugest√£o'] = revisao['Sugest√£o Revisada']
                erro_revisado['considera√ß√µes_enem'] = revisao['Considera√ß√µes ENEM']
                erros_revisados.append(erro_revisado)
                
        except Exception as e:
            logger.error(f"Erro ao revisar: {str(e)}")
            continue
    
    return erros_revisados

def revisar_erros_competency4(erros_identificados: List[Dict], redacao_texto: str) -> List[Dict]:
    """
    Revisa os erros identificados na Compet√™ncia 4.
    
    Args:
        erros_identificados: Lista de erros identificados
        redacao_texto: Texto completo da reda√ß√£o
        
    Returns:
        Lista de erros validados
    """
    MODELO_REVISAO_COMP4 = "ft:gpt-4o-2024-08-06:personal:competencia-4:AHDXewU3"
    erros_revisados = []
    
    for erro in erros_identificados:
        prompt_revisao = f"""
        Revise o seguinte erro identificado na Compet√™ncia 4 (Conhecimento dos Mecanismos Lingu√≠sticos) 
        de acordo com os crit√©rios espec√≠ficos do ENEM:

        Erro original:
        {json.dumps(erro, indent=2)}

        Texto da reda√ß√£o:
        {redacao_texto}

        Determine:
        1. Se o erro est√° corretamente identificado
        2. Se a explica√ß√£o e sugest√£o est√£o adequadas aos padr√µes do ENEM
        3. Se o erro impacta significativamente a coes√£o textual
        4. Se h√° considera√ß√µes adicionais relevantes para a avalia√ß√£o

        Formato da resposta:
        REVISAO
        Erro Confirmado: [Sim/N√£o]
        Explica√ß√£o Revisada: [Nova explica√ß√£o, se necess√°rio]
        Sugest√£o Revisada: [Nova sugest√£o, se necess√°rio]
        Considera√ß√µes ENEM: [Observa√ß√µes espec√≠ficas sobre o erro no contexto do ENEM]
        FIM_REVISAO
        """
        
        try:
            resposta_revisao = client.messages.create(
                model=MODELO_REVISAO_COMP4,
                messages=[{"role": "user", "content": prompt_revisao}],
                temperature=0.2
            )
            
            revisao = extrair_revisao_do_resultado(resposta_revisao.content)
            
            if revisao.get('Erro Confirmado') == 'Sim':
                erro_revisado = erro.copy()
                if 'Explica√ß√£o Revisada' in revisao:
                    erro_revisado['explica√ß√£o'] = revisao['Explica√ß√£o Revisada']
                if 'Sugest√£o Revisada' in revisao:
                    erro_revisado['sugest√£o'] = revisao['Sugest√£o Revisada']
                erro_revisado['considera√ß√µes_enem'] = revisao['Considera√ß√µes ENEM']
                erros_revisados.append(erro_revisado)
                
        except Exception as e:
            logger.error(f"Erro ao revisar: {str(e)}")
            continue
    
    return erros_revisados

def revisar_erros_competency5(erros_identificados: List[Dict], redacao_texto: str) -> List[Dict]:
    """
    Revisa os erros identificados na Compet√™ncia 5.
    
    Args:
        erros_identificados: Lista de erros identificados
        redacao_texto: Texto completo da reda√ß√£o
        
    Returns:
        Lista de erros validados
    """
    MODELO_REVISAO_COMP5 = "ft:gpt-4o-2024-08-06:personal:competencia-5:AHGVPnJG"
    erros_revisados = []
    
    for erro in erros_identificados:
        prompt_revisao = f"""
        Revise o seguinte erro identificado na Compet√™ncia 5 (Proposta de Interven√ß√£o) 
        de acordo com os crit√©rios espec√≠ficos do ENEM:

        Erro original:
        {json.dumps(erro, indent=2)}

        Texto da reda√ß√£o:
        {redacao_texto}

        Determine:
        1. Se o erro est√° corretamente identificado
        2. Se a explica√ß√£o e sugest√£o est√£o adequadas aos padr√µes do ENEM
        3. Se o erro impacta significativamente a qualidade da proposta de interven√ß√£o
        4. Se h√° considera√ß√µes adicionais relevantes para a avalia√ß√£o

        Formato da resposta:
        REVISAO
        Erro Confirmado: [Sim/N√£o]
        Explica√ß√£o Revisada: [Nova explica√ß√£o, se necess√°rio]
        Sugest√£o Revisada: [Nova sugest√£o, se necess√°rio]
        Considera√ß√µes ENEM: [Observa√ß√µes espec√≠ficas sobre o erro no contexto do ENEM]
        FIM_REVISAO
        """
        
        try:
            resposta_revisao = client.messages.create(
                model=MODELO_REVISAO_COMP5,
                messages=[{"role": "user", "content": prompt_revisao}],
                temperature=0.2
            )
            
            revisao = extrair_revisao_do_resultado(resposta_revisao.content)
            
            if revisao.get('Erro Confirmado') == 'Sim':
                erro_revisado = erro.copy()
                if 'Explica√ß√£o Revisada' in revisao:
                    erro_revisado['explica√ß√£o'] = revisao['Explica√ß√£o Revisada']
                if 'Sugest√£o Revisada' in revisao:
                    erro_revisado['sugest√£o'] = revisao['Sugest√£o Revisada']
                erro_revisado['considera√ß√µes_enem'] = revisao['Considera√ß√µes ENEM']
                erros_revisados.append(erro_revisado)
                
        except Exception as e:
            logger.error(f"Erro ao revisar: {str(e)}")
            continue
    
    return erros_revisados

def atribuir_nota_competency1(analise: str, erros: List[Dict[str, str]]) -> Dict[str, Any]:
    """
    Atribui nota √† Compet√™ncia 1 com base na an√°lise detalhada e erros identificados.
    
    Args:
        analise: String contendo a an√°lise detalhada do texto
        erros: Lista de dicion√°rios contendo os erros identificados
        
    Returns:
        Dict contendo a nota atribu√≠da (0-200) e sua justificativa
    """
    # Contar erros por categoria
    contagem_erros = {
        'sintaxe': 0,
        'ortografia': 0, 
        'concordancia': 0,
        'pontuacao': 0,
        'crase': 0,
        'registro': 0
    }
    
    for erro in erros:
        desc = erro.get('explicacao', '').lower()
        if 'sintax' in desc or 'estrutura' in desc:
            contagem_erros['sintaxe'] += 1
        if 'ortograf' in desc or 'accent' in desc or 'escrita' in desc:
            contagem_erros['ortografia'] += 1
        if 'concord' in desc or 'verbal' in desc or 'nominal' in desc:
            contagem_erros['concordancia'] += 1
        if 'pontu' in desc:
            contagem_erros['pontuacao'] += 1
        if 'crase' in desc:
            contagem_erros['crase'] += 1
        if 'coloquial' in desc or 'registro' in desc or 'informal' in desc:
            contagem_erros['registro'] += 1

    # Formatar erros para apresenta√ß√£o
    erros_formatados = ""
    for erro in erros:
        erros_formatados += f"""
        Erro encontrado:
        Trecho: "{erro.get('trecho', '')}"
        Explica√ß√£o: {erro.get('explicacao', '')}"
        Sugest√£o: {erro.get('sugestao', '')}
        """

    # Determinar nota base pelos crit√©rios objetivos
    total_erros = sum(contagem_erros.values())
    if (total_erros <= 3 and 
        contagem_erros['sintaxe'] <= 1 and
        contagem_erros['registro'] == 0 and
        contagem_erros['ortografia'] <= 1):
        nota_base = 200
    elif (total_erros <= 5 and 
          contagem_erros['sintaxe'] <= 2 and
          contagem_erros['registro'] <= 1):
        nota_base = 160
    elif (total_erros <= 8 and 
          contagem_erros['sintaxe'] <= 3):
        nota_base = 120
    elif total_erros <= 12:
        nota_base = 80
    elif total_erros <= 15:
        nota_base = 40
    else:
        nota_base = 0

    # Construir prompt para valida√ß√£o da nota
    prompt_nota = f"""
    Com base na seguinte an√°lise da Compet√™ncia 1 (Dom√≠nio da Norma Culta) e na contagem de erros identificados,
    confirme se a nota {nota_base} est√° adequada.
    
    AN√ÅLISE DETALHADA:
    {analise}
    
    CONTAGEM DE ERROS:
    - Erros de sintaxe/estrutura: {contagem_erros['sintaxe']}
    - Erros de ortografia/acentua√ß√£o: {contagem_erros['ortografia']}
    - Erros de concord√¢ncia: {contagem_erros['concordancia']}
    - Erros de pontua√ß√£o: {contagem_erros['pontuacao']}
    - Erros de crase: {contagem_erros['crase']}
    - Desvios de registro formal: {contagem_erros['registro']}
    Total de erros: {total_erros}
    
    ERROS ESPEC√çFICOS:
    {erros_formatados}
    """

    # Adicionar crit√©rios de avalia√ß√£o ao prompt
    prompt_nota += """
    Crit√©rios para cada nota:
    
    200 pontos:
    - No m√°ximo uma falha de estrutura sint√°tica
    - No m√°ximo dois desvios gramaticais
    - Nenhum uso de linguagem informal/coloquial
    - No m√°ximo um erro ortogr√°fico
    - Coer√™ncia e coes√£o impec√°veis
    - Sem repeti√ß√£o de erros
    
    160 pontos:
    - At√© tr√™s desvios gramaticais que n√£o comprometem a compreens√£o
    - Poucos erros de pontua√ß√£o/acentua√ß√£o
    - No m√°ximo tr√™s erros ortogr√°ficos
    - Bom dom√≠nio geral da norma culta
    
    120 pontos:
    - At√© cinco desvios gramaticais
    - Dom√≠nio mediano da norma culta
    - Alguns problemas de coes√£o pontuais
    - Erros n√£o sistem√°ticos
    
    80 pontos:
    - Estrutura sint√°tica deficit√°ria
    - Erros frequentes de concord√¢ncia
    - Uso ocasional de registro inadequado
    - Muitos erros de pontua√ß√£o/ortografia
    
    40 pontos:
    - Dom√≠nio prec√°rio da norma culta
    - Diversos desvios gramaticais frequentes
    - Problemas graves de coes√£o
    - Registro frequentemente inadequado
    
    0 pontos:
    - Desconhecimento total da norma culta
    - Erros graves e sistem√°ticos
    - Texto incompreens√≠vel
    
    Com base nesses crit√©rios e na an√°lise apresentada, forne√ßa:
    1. Confirma√ß√£o ou ajuste da nota base {nota_base}
    2. Justificativa detalhada relacionando os erros encontrados com os crit√©rios
    
    Formato da resposta:
    Nota: [NOTA FINAL]
    Justificativa: [Justificativa detalhada da nota, explicando como os erros e acertos se relacionam com os crit√©rios]
    """
    
    try:
        # Gerar resposta usando o modelo
        resposta_nota = client.messages.create(
            model="ft:gpt-4o-2024-08-06:personal:competencia-1:AHDQQucG",
            messages=[{"role": "user", "content": prompt_nota}],
            temperature=0.3
        )
        
        # Extrair nota e justificativa
        resultado = extrair_nota_e_justificativa(resposta_nota.content)
        
        # Validar se a nota est√° nos valores permitidos
        if resultado['nota'] not in [0, 40, 80, 120, 160, 200]:
            resultado['nota'] = nota_base
            resultado['justificativa'] += "\nNota ajustada para o valor v√°lido mais pr√≥ximo."
        
        # Validar discrep√¢ncia com nota base
        if abs(resultado['nota'] - nota_base) > 40:
            resultado['nota'] = min(nota_base, resultado['nota'])
            resultado['justificativa'] += "\nNota ajustada devido √† quantidade e gravidade dos erros identificados."
        
        return resultado
        
    except Exception as e:
        logger.error(f"Erro ao atribuir nota: {str(e)}")
        return {
            'nota': nota_base,
            'justificativa': "Erro ao gerar justificativa. Nota atribu√≠da com base nos crit√©rios objetivos."
        }

def atribuir_nota_competency2(analise: str, erros: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Atribui nota √† Compet√™ncia 2 com base na an√°lise e erros identificados.
    
    Args:
        analise: String contendo a an√°lise detalhada do texto
        erros: Lista de dicion√°rios contendo os erros identificados
        
    Returns:
        Dict contendo a nota atribu√≠da (0-200) e sua justificativa
    """
    prompt_nota = f"""
    Com base na seguinte an√°lise da Compet√™ncia 2 (Compreens√£o do Tema) do ENEM, atribua uma nota de 0 a 200 em intervalos de 40 pontos (0, 40, 80, 120, 160 ou 200).

    An√°lise:
    {analise}

    Erros identificados:
    {json.dumps(erros, indent=2)}

    Considere cuidadosamente os seguintes crit√©rios para atribuir a nota:

    Nota 200:
    - Excelente dom√≠nio do tema proposto.
    - Cita√ß√£o das palavras principais do tema ou sin√¥nimos em cada par√°grafo.
    - Argumenta√ß√£o consistente com repert√≥rio sociocultural produtivo.
    - Uso de exemplos hist√≥ricos, frases, m√∫sicas, textos, autores famosos, fil√≥sofos, estudos, artigos ou publica√ß√µes como repert√≥rio.
    - Excelente dom√≠nio do texto dissertativo-argumentativo, incluindo proposi√ß√£o, argumenta√ß√£o e conclus√£o.
    - N√£o copia trechos dos textos motivadores e demonstra clareza no ponto de vista adotado.
    - Estabelece v√≠nculo de ideias entre a refer√™ncia ao repert√≥rio e a discuss√£o proposta.
    - Cita a fonte do repert√≥rio (autor, obra, data de cria√ß√£o, etc.).
    - Inclui pelo menos um repert√≥rio no segundo e terceiro par√°grafo.

    Nota 160:
    - Bom desenvolvimento do tema com argumenta√ß√£o consistente, mas sem repert√≥rio sociocultural t√£o produtivo.
    - Completa as 3 partes do texto dissertativo-argumentativo (nenhuma delas √© embrion√°ria).
    - Bom dom√≠nio do texto dissertativo-argumentativo, com proposi√ß√£o, argumenta√ß√£o e conclus√£o claras, mas sem aprofundamento.
    - Utiliza informa√ß√µes pertinentes, mas sem extrapolar significativamente sua justificativa.

    Nota 120:
    - Abordagem completa do tema, com as 3 partes do texto dissertativo-argumentativo (podendo 1 delas ser embrion√°ria).
    - Repert√≥rio baseado nos textos motivadores e/ou repert√≥rio n√£o legitimado e/ou repert√≥rio legitimado, mas n√£o pertinente ao tema.
    - Desenvolvimento do tema de forma previs√≠vel, com argumenta√ß√£o mediana, sem grandes inova√ß√µes.
    - Dom√≠nio mediano do texto dissertativo-argumentativo, com proposi√ß√£o, argumenta√ß√£o e conclus√£o, mas de forma superficial.

    Nota 80:
    - Abordagem completa do tema, mas com problemas relacionados ao tipo textual e presen√ßa de muitos trechos de c√≥pia sem aspas.
    - Dom√≠nio insuficiente do texto dissertativo-argumentativo, faltando a estrutura completa de proposi√ß√£o, argumenta√ß√£o e conclus√£o.
    - N√£o desenvolve um ponto de vista claro e n√£o consegue conectar as ideias argumentativas adequadamente.
    - Duas partes embrion√°rias ou com conclus√£o finalizada por frase incompleta.

    Nota 40:
    - Tangencia o tema, sem abordar diretamente o ponto central proposto.
    - Dom√≠nio prec√°rio do texto dissertativo-argumentativo, com tra√ßos de outros tipos textuais.
    - N√£o constr√≥i uma argumenta√ß√£o clara e objetiva, resultando em confus√£o ou desvio do g√™nero textual.

    Nota 0:
    - Fuga completa do tema proposto, abordando um assunto irrelevante ou n√£o relacionado.
    - N√£o atende √† estrutura dissertativo-argumentativa, sendo classificado como outro g√™nero textual.
    - N√£o apresenta proposi√ß√£o, argumenta√ß√£o e conclus√£o, ou o texto √© anulado por n√£o atender aos crit√©rios b√°sicos de desenvolvimento textual.

    Forne√ßa a nota e uma justificativa detalhada, relacionando diretamente com a an√°lise fornecida e com os crit√©rios espec√≠ficos.

    Formato da resposta:
    Nota: [NOTA ATRIBU√çDA]
    Justificativa: [Justificativa detalhada da nota, explicando como cada aspecto da an√°lise se relaciona com os crit√©rios de pontua√ß√£o]
    """

    try:
        # Gerar resposta usando o modelo
        resposta_nota = client.messages.create(
            model="ft:gpt-4o-2024-08-06:personal:competencia-2:AHDT84HO",
            messages=[{"role": "user", "content": prompt_nota}],
            temperature=0.3
        )
        
        # Extrair nota e justificativa
        resultado = extrair_nota_e_justificativa(resposta_nota.content)
        
        # Validar se a nota est√° nos valores permitidos
        if resultado['nota'] not in [0, 40, 80, 120, 160, 200]:
            nota_ajustada = 40 * round(resultado['nota'] / 40)
            resultado['nota'] = max(0, min(200, nota_ajustada))
            resultado['justificativa'] += "\nNota ajustada para o valor v√°lido mais pr√≥ximo."
        
        return resultado
        
    except Exception as e:
        logger.error(f"Erro ao atribuir nota: {str(e)}")
        return {
            'nota': 0,
            'justificativa': "Erro ao gerar nota e justificativa."
        }

def atribuir_nota_competency3(analise: str, erros: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Atribui nota √† Compet√™ncia 3 com base na an√°lise e erros identificados.
    
    Args:
        analise: String contendo a an√°lise detalhada do texto
        erros: Lista de dicion√°rios contendo os erros identificados
        
    Returns:
        Dict contendo a nota atribu√≠da (0-200) e sua justificativa
    """
    prompt_nota = f"""
    Com base na seguinte an√°lise da Compet√™ncia 3 (Sele√ß√£o e Organiza√ß√£o das Informa√ß√µes) do ENEM, atribua uma nota de 0 a 200 em intervalos de 40 pontos (0, 40, 80, 120, 160 ou 200).

    An√°lise:
    {analise}

    Erros identificados:
    {json.dumps(erros, indent=2)}

    Considere cuidadosamente os seguintes crit√©rios para atribuir a nota:

    Nota 200:
    - Ideias progressivas e argumentos bem selecionados, revelando um planejamento claro do texto.
    - Apresenta informa√ß√µes, fatos e opini√µes relacionados ao tema proposto e aos seus argumentos, de forma consistente e organizada, em defesa de um ponto de vista.
    - Demonstra autoria, com informa√ß√µes e argumentos originais que refor√ßam o ponto de vista do aluno.
    - Mant√©m o encadeamento das ideias, com cada par√°grafo apresentando informa√ß√µes coerentes com o anterior, sem repeti√ß√µes desnecess√°rias ou saltos tem√°ticos.
    - Apresenta poucas falhas, e essas falhas n√£o prejudicam a progress√£o do texto.

    Nota 160:
    - Apresenta informa√ß√µes, fatos e opini√µes relacionados ao tema, de forma organizada, com ind√≠cios de autoria em defesa de um ponto de vista.
    - Ideias claramente organizadas, mas n√£o t√£o consistentes quanto o esperado para uma argumenta√ß√£o mais s√≥lida.
    - Organiza√ß√£o geral das ideias √© boa, mas algumas informa√ß√µes e opini√µes n√£o est√£o bem desenvolvidas.

    Nota 120:
    - Apresenta informa√ß√µes, fatos e opini√µes relacionados ao tema, mas limitados aos argumentos dos textos motivadores e pouco organizados, em defesa de um ponto de vista.
    - Ideias previs√≠veis, sem desenvolvimento profundo ou originalidade, com pouca evid√™ncia de autoria.
    - Argumentos simples, sem clara progress√£o de ideias, e baseado principalmente nas sugest√µes dos textos motivadores.

    Nota 80:
    - Apresenta informa√ß√µes, fatos e opini√µes relacionados ao tema, mas de forma desorganizada ou contradit√≥ria, e limitados aos argumentos dos textos motivadores.
    - Ideias n√£o est√£o bem conectadas, demonstrando falta de coer√™ncia e organiza√ß√£o no desenvolvimento do texto.
    - Argumentos inconsistentes ou contradit√≥rios, prejudicando a defesa do ponto de vista.
    - Perde linhas com informa√ß√µes irrelevantes, repetidas ou excessivas.

    Nota 40:
    - Apresenta informa√ß√µes, fatos e opini√µes pouco relacionados ao tema, com incoer√™ncias, e sem defesa clara de um ponto de vista.
    - Falta de organiza√ß√£o e ideias dispersas, sem desenvolvimento coerente.
    - N√£o apresenta um ponto de vista claro, e os argumentos s√£o fracos ou desconexos.

    Nota 0:
    - Apresenta informa√ß√µes, fatos e opini√µes n√£o relacionados ao tema, sem coer√™ncia, e sem defesa de um ponto de vista.
    - Ideias totalmente desconexas, sem organiza√ß√£o ou rela√ß√£o com o tema proposto.
    - N√£o desenvolve qualquer argumento relevante ou coerente, demonstrando falta de planejamento.

    Forne√ßa a nota e uma justificativa detalhada, relacionando diretamente com a an√°lise fornecida e com os crit√©rios espec√≠ficos.

    Formato da resposta:
    Nota: [NOTA ATRIBU√çDA]
    Justificativa: [Justificativa detalhada da nota, explicando como cada aspecto da an√°lise se relaciona com os crit√©rios de pontua√ß√£o]
    """

    try:
        # Gerar resposta usando o modelo
        resposta_nota = client.messages.create(
            model="ft:gpt-4o-2024-08-06:personal:competencia-3:AHDUfZRb",
            messages=[{"role": "user", "content": prompt_nota}],
            temperature=0.3
        )
        
        # Extrair nota e justificativa
        resultado = extrair_nota_e_justificativa(resposta_nota.content)
        
        # Validar se a nota est√° nos valores permitidos
        if resultado['nota'] not in [0, 40, 80, 120, 160, 200]:
            nota_ajustada = 40 * round(resultado['nota'] / 40)
            resultado['nota'] = max(0, min(200, nota_ajustada))
            resultado['justificativa'] += "\nNota ajustada para o valor v√°lido mais pr√≥ximo."
        
        return resultado
        
    except Exception as e:
        logger.error(f"Erro ao atribuir nota: {str(e)}")
        return {
            'nota': 0,
            'justificativa': "Erro ao gerar nota e justificativa."
        }

def atribuir_nota_competency4(analise: str, erros: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Atribui nota √† Compet√™ncia 4 com base na an√°lise e erros identificados.
    
    Args:
        analise: String contendo a an√°lise detalhada do texto
        erros: Lista de dicion√°rios contendo os erros identificados
        
    Returns:
        Dict contendo a nota atribu√≠da (0-200) e sua justificativa
    """
    prompt_nota = f"""
    Com base na seguinte an√°lise da Compet√™ncia 4 (Conhecimento dos Mecanismos Lingu√≠sticos) do ENEM, atribua uma nota de 0 a 200 em intervalos de 40 pontos (0, 40, 80, 120, 160 ou 200).

    An√°lise:
    {analise}

    Erros identificados:
    {json.dumps(erros, indent=2)}

    Considere cuidadosamente os seguintes crit√©rios para atribuir a nota:

    Nota 200:
    - Utiliza conectivos em todo in√≠cio de per√≠odo.
    - Articula bem as partes do texto e apresenta um repert√≥rio diversificado de recursos coesivos, conectando par√°grafos e per√≠odos de forma fluida.
    - Utiliza referencia√ß√£o adequada, com pronomes, sin√¥nimos e adv√©rbios, garantindo coes√£o e clareza.
    - Apresenta transi√ß√µes claras e bem estruturadas entre as ideias de causa/consequ√™ncia, compara√ß√£o e conclus√£o, sem falhas.
    - Demonstra excelente organiza√ß√£o de per√≠odos complexos, com uma articula√ß√£o eficiente entre ora√ß√µes.
    - N√£o repete muitos conectivos ao longo do texto.

    Nota 160:
    - Deixa de usar uma ou duas vezes conectivos ao longo do texto.
    - Articula as partes do texto, mas com poucas inadequa√ß√µes ou problemas pontuais na conex√£o de ideias.
    - Apresenta um repert√≥rio diversificado de recursos coesivos, mas com algumas falhas no uso de pronomes, adv√©rbios ou sin√¥nimos.
    - As transi√ß√µes entre par√°grafos e ideias s√£o adequadas, mas com pequenos deslizes na estrutura√ß√£o dos per√≠odos complexos.
    - Mant√©m boa coes√£o e coer√™ncia, mas com algumas falhas na articula√ß√£o entre causas, consequ√™ncias e exemplos.

    Nota 120:
    - N√£o usa muitos conectivos ao longo dos par√°grafos.
    - Repete v√°rias vezes o mesmo conectivo ao longo do par√°grafo.
    - Articula as partes do texto de forma mediana, apresentando inadequa√ß√µes frequentes na conex√£o de ideias.
    - O repert√≥rio de recursos coesivos √© pouco diversificado, com uso repetitivo de pronomes.
    - Apresenta transi√ß√µes previs√≠veis e pouco elaboradas, prejudicando o encadeamento l√≥gico das ideias.
    - A organiza√ß√£o dos per√≠odos √© mediana, com algumas ora√ß√µes mal articuladas, comprometendo a fluidez do texto.

    Nota 80:
    - Articula as partes do texto de forma insuficiente, com muitas inadequa√ß√µes no uso de conectivos e outros recursos coesivos.
    - O repert√≥rio de recursos coesivos √© limitado, resultando em repeti√ß√£o excessiva ou uso inadequado de pronomes e adv√©rbios.
    - Apresenta conex√µes falhas entre os par√°grafos, com transi√ß√µes abruptas e pouco claras entre as ideias.
    - Os per√≠odos complexos est√£o mal estruturados, com ora√ß√µes desconectadas ou confusas.

    Nota 40:
    - Articula as partes do texto de forma prec√°ria, com s√©rias falhas na conex√£o de ideias.
    - O repert√≥rio de recursos coesivos √© praticamente inexistente, sem o uso adequado de pronomes, conectivos ou adv√©rbios.
    - Apresenta par√°grafos desarticulados, sem rela√ß√£o clara entre as ideias.
    - Os per√≠odos s√£o curtos e desconectados, sem estrutura√ß√£o adequada ou progress√£o de ideias.

    Nota 0:
    - N√£o articula as informa√ß√µes e as ideias parecem desconexas e sem coes√£o.
    - O texto n√£o apresenta recursos coesivos, resultando em total falta de conex√£o entre as partes.
    - Os par√°grafos e per√≠odos s√£o desorganizados, sem qualquer l√≥gica na apresenta√ß√£o das ideias.
    - O texto n√£o utiliza mecanismos de coes√£o (pronomes, conectivos, adv√©rbios), tornando-o incompreens√≠vel.

    Forne√ßa a nota e uma justificativa detalhada, relacionando diretamente com a an√°lise fornecida e com os crit√©rios espec√≠ficos.

    Formato da resposta:
    Nota: [NOTA ATRIBU√çDA]
    Justificativa: [Justificativa detalhada da nota, explicando como cada aspecto da an√°lise se relaciona com os crit√©rios de pontua√ß√£o]
    """

    try:
        # Gerar resposta usando o modelo
        resposta_nota = client.messages.create(
            model="ft:gpt-4o-2024-08-06:personal:competencia-4:AHDXewU3",
            messages=[{"role": "user", "content": prompt_nota}],
            temperature=0.3
        )
        
        # Extrair nota e justificativa
        resultado = extrair_nota_e_justificativa(resposta_nota.content)
        
        # Validar se a nota est√° nos valores permitidos
        if resultado['nota'] not in [0, 40, 80, 120, 160, 200]:
            nota_ajustada = 40 * round(resultado['nota'] / 40)
            resultado['nota'] = max(0, min(200, nota_ajustada))
            resultado['justificativa'] += "\nNota ajustada para o valor v√°lido mais pr√≥ximo."
        
        return resultado
        
    except Exception as e:
        logger.error(f"Erro ao atribuir nota: {str(e)}")
        return {
            'nota': 0,
            'justificativa': "Erro ao gerar nota e justificativa."
        }

def atribuir_nota_competency5(analise: str, erros: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Atribui nota √† Compet√™ncia 5 com base na an√°lise e erros identificados.
    
    Args:
        analise: String contendo a an√°lise detalhada do texto
        erros: Lista de dicion√°rios contendo os erros identificados
        
    Returns:
        Dict contendo a nota atribu√≠da (0-200) e sua justificativa
    """
    prompt_nota = f"""
    Com base na seguinte an√°lise da Compet√™ncia 5 (Proposta de Interven√ß√£o) do ENEM, atribua uma nota de 0 a 200 em intervalos de 40 pontos (0, 40, 80, 120, 160 ou 200).

    An√°lise:
    {analise}

    Erros identificados:
    {json.dumps(erros, indent=2)}

    Considere cuidadosamente os seguintes crit√©rios para atribuir a nota:

    Nota 200:
    - Elabora proposta de interven√ß√£o completa, detalhada e relacionada ao tema.
    - Apresenta os 5 elementos obrigat√≥rios:
      * Agente(s) que executar√°(√£o) a a√ß√£o
      * A√ß√£o(√µes) para resolver o problema
      * Modo/meio de execu√ß√£o da a√ß√£o
      * Detalhamento da execu√ß√£o e/ou dos efeitos esperados
      * Finalidade/objetivo da proposta
    - Proposta √© completamente pertinente ao tema e bem articulada √† discuss√£o desenvolvida no texto.
    - Demonstra respeito aos direitos humanos.
    - Apresenta detalhamento dos meios, modos e/ou instrumentos para cada a√ß√£o sugerida.
    - Proposta √© vi√°vel e bem desenvolvida.

    Nota 160:
    - Elabora proposta de interven√ß√£o relacionada ao tema.
    - Apresenta 4 dos elementos obrigat√≥rios.
    - Proposta √© pertinente ao tema e articulada √† discuss√£o desenvolvida no texto.
    - Demonstra respeito aos direitos humanos.
    - Apresenta detalhamento, mas com algumas falhas ou omiss√µes.
    - Proposta √© vi√°vel mas precisa de alguns ajustes.

    Nota 120:
    - Elabora proposta de interven√ß√£o relacionada ao tema.
    - Apresenta 3 dos elementos obrigat√≥rios.
    - Proposta √© pertinente ao tema mas pouco articulada √† discuss√£o.
    - Demonstra respeito aos direitos humanos.
    - Apresenta detalhamento insuficiente.
    - Proposta √© parcialmente vi√°vel.

    Nota 80:
    - Elabora proposta de interven√ß√£o tangencial ao tema.
    - Apresenta apenas 2 dos elementos obrigat√≥rios.
    - Proposta tem articula√ß√£o fraca com a discuss√£o.
    - Demonstra respeito aos direitos humanos.
    - Praticamente n√£o h√° detalhamento.
    - Proposta tem viabilidade question√°vel.

    Nota 40:
    - Elabora proposta de interven√ß√£o tangencial ao tema.
    - Apresenta apenas 1 dos elementos obrigat√≥rios.
    - Proposta n√£o se articula com a discuss√£o.
    - Demonstra respeito aos direitos humanos.
    - N√£o h√° detalhamento.
    - Proposta n√£o demonstra viabilidade.

    Nota 0:
    - N√£o elabora proposta de interven√ß√£o.
    - Ou: elabora proposta n√£o relacionada ao tema.
    - Ou: elabora proposta que desrespeita os direitos humanos.

    Forne√ßa a nota e uma justificativa detalhada, relacionando diretamente com a an√°lise fornecida e com os crit√©rios espec√≠ficos.

    Formato da resposta:
    Nota: [NOTA ATRIBU√çDA]
    Justificativa: [Justificativa detalhada da nota, explicando como cada aspecto da an√°lise se relaciona com os crit√©rios de pontua√ß√£o]
    """

    try:
        # Gerar resposta usando o modelo
        resposta_nota = client.messages.create(
            model="ft:gpt-4o-2024-08-06:personal:competencia-5:AHGVPnJG",
            messages=[{"role": "user", "content": prompt_nota}],
            temperature=0.3
        )
        
        # Extrair nota e justificativa
        resultado = extrair_nota_e_justificativa(resposta_nota.content)
        
        # Validar se a nota est√° nos valores permitidos
        if resultado['nota'] not in [0, 40, 80, 120, 160, 200]:
            nota_ajustada = 40 * round(resultado['nota'] / 40)
            resultado['nota'] = max(0, min(200, nota_ajustada))
            resultado['justificativa'] += "\nNota ajustada para o valor v√°lido mais pr√≥ximo."
        
        return resultado
        
    except Exception as e:
        logger.error(f"Erro ao atribuir nota: {str(e)}")
        return {
            'nota': 0,
            'justificativa': "Erro ao gerar nota e justificativa."
        }

import json
import logging
from elevenlabs import generate, set_api_key
import openai

logger = logging.getLogger(__name__)

class RedacaoTutor:
    """Sistema de tutoria inteligente para reda√ß√µes do ENEM"""
    def __init__(self, openai_api_key: str, elevenlabs_api_key: str, competencies: dict):
        # Configura√ß√£o das APIs
        openai.api_key = openai_api_key
        set_api_key(elevenlabs_api_key)
        self.competencies = competencies

    def iniciar_tutoria(self, resultados_analise: dict) -> dict:
        """
        Inicia uma sess√£o de tutoria baseada nos resultados da an√°lise.
        """
        try:
            erros_por_competencia = resultados_analise['erros_especificos']
            notas = resultados_analise['notas']
            analises = resultados_analise['analises_detalhadas']
            competencia_foco = min(notas.items(), key=lambda x: x[1])[0]
            return self.criar_plano_tutoria(
                competencia_foco,
                erros_por_competencia.get(competencia_foco, []),
                notas.get(competencia_foco, 0),
                analises.get(competencia_foco, "")
            )
        except Exception as e:
            logger.error(f"Erro ao iniciar tutoria: {e}")
            return {}

    def criar_plano_tutoria(self, competencia: str, erros: list, nota: int, analise: str) -> dict:
        """
        Cria um plano de tutoria personalizado.
        """
        prompt = f"""
        Com base na an√°lise desta reda√ß√£o na compet√™ncia {self.competencies.get(competencia, "Desconhecida")}:
        Nota: {nota}/200
        An√°lise: {analise}
        Erros identificados: {json.dumps(erros, indent=2)}

        Crie um plano de tutoria que inclua:
        1. Diagn√≥stico detalhado
        2. Sequ√™ncia de exerc√≠cios
        3. Pontos de checagem
        4. Recomenda√ß√µes de estudo
        5. Crit√©rios de avan√ßo

        Responda em formato JSON:
        {{
            "diagnostico": {{}},
            "plano_estudo": {{}},
            "recomendacoes": []
        }}
        """
        try:
            response = openai.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "Voc√™ √© um tutor especializado em reda√ß√£o para o ENEM."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=1500
            )
            return json.loads(response['choices'][0]['message']['content'])
        except Exception as e:
            logger.error(f"Erro ao criar plano de tutoria: {e}")
            return {}

    def gerar_audio_feedback(self, texto: str) -> bytes:
        """
        Gera √°udio do feedback usando ElevenLabs em Portugu√™s do Brasil.
        """
        try:
            audio = generate(
                text=texto,
                voice="Ana",  # Use uma voz compat√≠vel com PT-BR, ex.: "Ana"
                model="eleven_monolingual_v1"
            )
            return audio
        except Exception as e:
            logger.error(f"Erro ao gerar √°udio: {e}")
            return b""

    def avaliar_resposta(self, exercicio: dict, resposta: str, competencia: str) -> dict:
        """
        Avalia resposta do aluno para um exerc√≠cio.
        """
        prompt = f"""
        Avalie a seguinte resposta para um exerc√≠cio da compet√™ncia {self.competencies.get(competencia, "Desconhecida")}:
        Exerc√≠cio: {json.dumps(exercicio, indent=2)}
        Resposta do aluno: {resposta}

        Crit√©rios de avalia√ß√£o: {json.dumps(exercicio.get("criterios_avaliacao", []), indent=2)}

        Responda em JSON:
        {{
            "feedback_geral": "",
            "pontos_positivos": [],
            "areas_melhoria": [],
            "proximos_passos": [],
            "pontuacao": 0
        }}
        """
        try:
            response = openai.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "Voc√™ √© um avaliador especializado em reda√ß√£o para o ENEM."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=1000
            )
            return json.loads(response['choices'][0]['message']['content'])
        except Exception as e:
            logger.error(f"Erro ao avaliar resposta: {e}")
            return {
                "feedback_geral": "N√£o foi poss√≠vel avaliar a resposta.",
                "pontos_positivos": [],
                "areas_melhoria": [],
                "proximos_passos": [],
                "pontuacao": 0
            }

    def gerar_feedback_final(self, competencia: str, historico_exercicios: list) -> dict:
        """
        Gera feedback final da sess√£o de tutoria.
        """
        prompt = f"""
        Gere um feedback final para a sess√£o de tutoria em {self.competencies.get(competencia, "Desconhecida")}.
        Hist√≥rico de exerc√≠cios:
        {json.dumps(historico_exercicios, indent=2)}

        Forne√ßa:
        1. An√°lise do progresso
        2. Principais conquistas
        3. √Åreas que ainda precisam de aten√ß√£o
        4. Recomenda√ß√µes para estudo cont√≠nuo
        5. Pr√≥ximos objetivos sugeridos

        Responda em formato JSON:
        {{
            "analise_progresso": "",
            "conquistas": [],
            "areas_atencao": [],
            "recomendacoes": [],
            "proximos_objetivos": [],
            "mensagem_motivacional": ""
        }}
        """
        try:
            response = openai.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "Voc√™ √© um tutor especializado em reda√ß√£o para o ENEM."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=1500
            )
            feedback = json.loads(response['choices'][0]['message']['content'])
            
            if "mensagem_motivacional" in feedback:
                feedback['audio'] = self.gerar_audio_feedback(feedback["mensagem_motivacional"])
            return feedback
        except Exception as e:
            logger.error(f"Erro ao gerar feedback final: {e}")
            return {}


def pagina_tutoria():
    """P√°gina principal do sistema de tutoria"""
    st.title("Sistema de Tutoria Personalizada")

    # Verificar se h√° an√°lise dispon√≠vel
    if 'resultados' not in st.session_state:
        st.warning("√â necess√°rio analisar uma reda√ß√£o primeiro para iniciar a tutoria.")
        if st.button("Enviar Reda√ß√£o"):
            st.session_state.page = 'envio'
            st.rerun()
        return

    # Inicializar o tutor se necess√°rio
    if 'tutor' not in st.session_state:
        st.session_state.tutor = RedacaoTutor(client, generate)

    # Inicializar estados da tutoria se necess√°rio
    if 'tutoria_estado' not in st.session_state:
        st.session_state.tutoria_estado = {
            'etapa': 'diagnostico',
            'competencia_foco': None,
            'exercicios_completos': set(),
            'pontuacao': 0,
            'historico': []
        }

    # Barra lateral com progresso e informa√ß√µes
    with st.sidebar:
        st.subheader("Seu Progresso")
        progresso = calcular_progresso_tutoria(st.session_state.tutoria_estado['etapa'])
        st.progress(progresso)
        st.metric("Pontua√ß√£o", st.session_state.tutoria_estado['pontuacao'])
        
        if st.session_state.tutoria_estado['competencia_foco']:
            st.write(f"Foco atual: {COMPETENCIES[st.session_state.tutoria_estado['competencia_foco']]}")

    # L√≥gica principal baseada na etapa atual
    etapa = st.session_state.tutoria_estado['etapa']
    
    if etapa == 'diagnostico':
        mostrar_diagnostico_inicial()
    elif etapa == 'plano_estudo':
        mostrar_plano_estudo()
    elif etapa == 'exercicios':
        mostrar_exercicios()
    elif etapa == 'feedback':
        mostrar_feedback_final()

def mostrar_diagnostico_inicial():
    """Mostra diagn√≥stico inicial e permite escolha de compet√™ncia foco"""
    st.subheader("Diagn√≥stico Inicial")

    resultados = st.session_state.resultados
    notas = resultados['notas']
    
    # Mostrar gr√°fico de compet√™ncias
    criar_grafico_radar(notas)
    
    # Identificar compet√™ncia mais fraca
    competencia_mais_fraca = min(notas.items(), key=lambda x: x[1])[0]
    
    # Permitir escolha da compet√™ncia
    st.info(f"Compet√™ncia recomendada: {COMPETENCIES[competencia_mais_fraca]}")
    
    competencia_escolhida = st.selectbox(
        "Escolha a compet√™ncia para trabalhar:",
        list(COMPETENCIES.keys()),
        format_func=lambda x: f"{COMPETENCIES[x]} (Nota: {notas[x]}/200)",
        index=list(COMPETENCIES.keys()).index(competencia_mais_fraca)
    )
    
    if st.button("Iniciar Plano de Estudos"):
        # Gerar plano de tutoria
        plano = st.session_state.tutor.criar_plano_tutoria(
            competencia_escolhida,
            resultados['erros_especificos'][competencia_escolhida],
            notas[competencia_escolhida],
            resultados['analises_detalhadas'][competencia_escolhida]
        )
        
        # Atualizar estado
        st.session_state.tutoria_estado.update({
            'etapa': 'plano_estudo',
            'competencia_foco': competencia_escolhida,
            'plano_atual': plano
        })
        st.rerun()

def mostrar_plano_estudo():
    """Mostra e gerencia o plano de estudos personalizado"""
    st.subheader("Seu Plano de Estudos")
    
    plano = st.session_state.tutoria_estado['plano_atual']
    
    # Mostrar diagn√≥stico
    with st.expander("Diagn√≥stico", expanded=True):
        st.write("**Principais Dificuldades:**")
        for dif in plano['diagnostico']['dificuldades_principais']:
            st.write(f"- {dif}")
            
        st.write("**Pontos Fortes:**")
        for ponto in plano['diagnostico']['pontos_fortes']:
            st.write(f"- {ponto}")
    
    # Mostrar m√≥dulos de estudo
    st.subheader("M√≥dulos de Estudo")
    for i, modulo in enumerate(plano['plano_estudo']['modulos']):
        with st.expander(f"üìö M√≥dulo {i+1}: {modulo['titulo']}", expanded=i==0):
            st.write(f"**Objetivo:** {modulo['objetivo']}")
            
            st.write("**Exerc√≠cios:**")
            for ex in modulo['exercicios']:
                st.write(f"- {ex}")
                
            st.write("**Recursos:**")
            for rec in modulo['recursos']:
                st.write(f"- {rec}")
    
    # Mostrar recomenda√ß√µes
    with st.expander("üìù Recomenda√ß√µes"):
        for rec in plano['recomendacoes']:
            st.write(f"- {rec}")
    
    if st.button("Come√ßar Exerc√≠cios"):
        st.session_state.tutoria_estado['etapa'] = 'exercicios'
        st.rerun()

def mostrar_exercicios():
    """Mostra e gerencia os exerc√≠cios pr√°ticos"""
    st.subheader("Exerc√≠cios Pr√°ticos")
    
    # Gerar novo exerc√≠cio se necess√°rio
    if 'exercicio_atual' not in st.session_state.tutoria_estado:
        exercicio = st.session_state.tutor.gerar_exercicio(
            st.session_state.tutoria_estado['competencia_foco'],
            'intermedi√°rio'  # Poderia ser din√¢mico baseado no desempenho
        )
        st.session_state.tutoria_estado['exercicio_atual'] = exercicio
    
    exercicio = st.session_state.tutoria_estado['exercicio_atual']
    
    # Mostrar exerc√≠cio
    st.markdown(f"### {exercicio['titulo']}")
    st.write(exercicio['instrucoes'])
    
    # Mostrar exemplos
    with st.expander("Ver Exemplos"):
        for ex in exercicio['exemplos']:
            st.write(f"- {ex}")
    
    # √Årea para resposta
    resposta = st.text_area(
        "Sua resposta:",
        height=200,
        key="resposta_exercicio"
    )
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("Verificar"):
            if resposta:
                feedback = st.session_state.tutor.avaliar_resposta(
                    exercicio,
                    resposta,
                    st.session_state.tutoria_estado['competencia_foco']
                )
                
                # Mostrar feedback
                st.write("### Feedback")
                st.write(feedback['feedback_geral'])
                
                with st.expander("Detalhes"):
                    st.write("**Pontos Positivos:**")
                    for ponto in feedback['pontos_positivos']:
                        st.write(f"- {ponto}")
                        
                    st.write("**√Åreas de Melhoria:**")
                    for area in feedback['areas_melhoria']:
                        st.write(f"- {area}")
                
                # Atualizar pontua√ß√£o
                st.session_state.tutoria_estado['pontuacao'] += feedback['pontuacao']
                
                # Adicionar ao hist√≥rico
                st.session_state.tutoria_estado['historico'].append({
                    'exercicio': exercicio,
                    'resposta': resposta,
                    'feedback': feedback
                })
                
                # Reproduzir feedback em √°udio
                if 'audio' in feedback:
                    st.audio(feedback['audio'])
            else:
                st.warning("Por favor, forne√ßa uma resposta antes de verificar.")
    
    with col2:
        if st.button("Pr√≥ximo Exerc√≠cio"):
            del st.session_state.tutoria_estado['exercicio_atual']
            st.rerun()

def mostrar_feedback_final():
    """Mostra feedback final e conclus√£o da tutoria"""
    st.subheader("Feedback Final")
    
    feedback = st.session_state.tutor.gerar_feedback_final(
        st.session_state.tutoria_estado['competencia_foco'],
        st.session_state.tutoria_estado['historico']
    )
    
    st.write(feedback['analise_progresso'])
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.write("**Principais Conquistas:**")
        for conquista in feedback['conquistas']:
            st.write(f"- {conquista}")
            
        st.write("**Pr√≥ximos Objetivos:**")
        for obj in feedback['proximos_objetivos']:
            st.write(f"- {obj}")
    
    with col2:
        st.write("**√Åreas para Aten√ß√£o:**")
        for area in feedback['areas_atencao']:
            st.write(f"- {area}")
            
        st.write("**Recomenda√ß√µes:**")
        for rec in feedback['recomendacoes']:
            st.write(f"- {rec}")
    
    if 'audio' in feedback:
        st.audio(feedback['audio'])
    
    if st.button("Concluir Tutoria"):
        # Resetar estado da tutoria
        st.session_state.tutoria_estado = {
            'etapa': 'diagnostico',
            'competencia_foco': None,
            'exercicios_completos': set(),
            'pontuacao': 0,
            'historico': []
        }
        st.rerun()

def calcular_progresso_tutoria(etapa: str) -> float:
    """Calcula o progresso da tutoria baseado na etapa atual"""
    etapas = {
        'diagnostico': 0.25,
        'plano_estudo': 0.5,
        'exercicios': 0.75,
        'feedback': 1.0
    }
    return etapas.get(etapa, 0.0)

def extrair_erros_do_resultado(resultado: str) -> List[Dict[str, str]]:
    """
    Extrai erros do texto de resultado da an√°lise.
    
    Args:
        resultado: String contendo o resultado da an√°lise
        
    Returns:
        Lista de dicion√°rios contendo os erros identificados
    """
    erros = []
    padrao_erro = re.compile(r'ERRO\n(.*?)\nFIM_ERRO', re.DOTALL)
    matches = padrao_erro.findall(resultado)
    
    for match in matches:
        erro = {}
        for linha in match.split('\n'):
            if ':' in linha:
                chave, valor = linha.split(':', 1)
                chave = chave.strip().lower()
                valor = valor.strip()
                if chave == 'trecho':
                    valor = valor.strip('"')
                erro[chave] = valor
        if 'descri√ß√£o' in erro and 'trecho' in erro:
            erros.append(erro)
    
    return erros

def criar_grafico_radar(notas: Dict[str, int]):
    """
    Cria e exibe gr√°fico radar das compet√™ncias.
    
    Args:
        notas: Dicion√°rio com notas de cada compet√™ncia
    """
    categorias = list(COMPETENCIES.values())
    valores = [notas[f"competency{i+1}"] for i in range(5)]
    
    fig = go.Figure(data=go.Scatterpolar(
        r=valores,
        theta=categorias,
        fill='toself',
        line=dict(color='#4CAF50', width=2),
        marker=dict(size=8)
    ))
    
    fig.update_layout(
        polar=dict(
            radialaxis=dict(
                visible=True,
                range=[0, 200],
                tickmode='linear',
                tick0=0,
                dtick=40,
                gridcolor='rgba(0,0,0,0.1)'
            ),
            angularaxis=dict(
                gridcolor='rgba(0,0,0,0.1)'
            )
        ),
        showlegend=False,
        title={
            'text': 'Perfil de Compet√™ncias',
            'y':0.95,
            'x':0.5,
            'xanchor': 'center',
            'yanchor': 'top',
            'font': dict(size=20)
        },
        paper_bgcolor='white'
    )
    
    st.plotly_chart(fig, use_container_width=True)

def extrair_nota_e_justificativa(resposta: str) -> Dict[str, Any]:
    """
    Extrai nota e justificativa do texto de resposta.
    
    Args:
        resposta: String contendo a resposta do modelo
        
    Returns:
        Dict contendo nota e justificativa
    """
    linhas = resposta.strip().split('\n')
    nota = None
    justificativa = []
    
    lendo_justificativa = False
    
    for linha in linhas:
        linha = linha.strip()
        if linha.startswith('Nota:'):
            try:
                nota = int(linha.split(':')[1].strip())
            except ValueError:
                raise ValueError("Formato de nota inv√°lido")
        elif linha.startswith('Justificativa:'):
            lendo_justificativa = True
        elif lendo_justificativa and linha:
            justificativa.append(linha)
    
    if nota is None:
        raise ValueError("Nota n√£o encontrada na resposta")
        
    return {
        'nota': nota,
        'justificativa': ' '.join(justificativa)
    }

def validar_redacao(texto: str, tema: str) -> Tuple[bool, str]:
    """
    Valida o texto da reda√ß√£o e o tema.
    
    Args:
        texto: Texto da reda√ß√£o
        tema: Tema da reda√ß√£o
        
    Returns:
        Tupla (√©_v√°lido, mensagem_erro)
    """
    if not texto or not texto.strip():
        return False, "O texto da reda√ß√£o n√£o pode estar vazio."
        
    if not tema or not tema.strip():
        return False, "O tema da reda√ß√£o n√£o pode estar vazio."
        
    palavras = len(texto.split())
    if palavras < 50:
        return False, f"Texto muito curto ({palavras} palavras). M√≠nimo recomendado: 400 palavras."
        
    if palavras > 3000:
        return False, f"Texto muito longo ({palavras} palavras). M√°ximo recomendado: 3000 palavras."
        
    return True, ""

def formatar_erro(erro: Dict[str, str]) -> str:
    """
    Formata erro para exibi√ß√£o.
    
    Args:
        erro: Dicion√°rio contendo informa√ß√µes do erro
        
    Returns:
        String formatada do erro
    """
    return f"""
    **Erro encontrado:**
    - Trecho: "{erro.get('trecho', '')}"
    - Explica√ß√£o: {erro.get('explicacao', '')}"
    - Sugest√£o: {erro.get('sugestao', '')}
    """

ERROR:__main__:Erro na inicializa√ß√£o dos clientes: module 'openai' has no attribute 'Client'

[12:38:10] üîÑ Updated app!

ERROR:__main__:Erro na inicializa√ß√£o dos clientes: module 'openai' has no attribute 'Client'
